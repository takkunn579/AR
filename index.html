<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>AR Photo Booth</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- ライブラリをより新しく安定したバージョンに更新 -->
    <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/donmccurdy/aframe-extras@v6.1.1/dist/aframe-extras.min.js"></script>
    <!-- ジェスチャー（ピンチ操作など）用のライブラリ -->
    <script src="https://raw.githack.com/fcor/arjs-gestures/master/dist/gestures.js"></script>

    <style>
        /* 撮影後のプレビュー画面のスタイル */
        #preview {
            /* 最初は非表示にしておく */
            display: none; 
            
            /* 画面全体を覆う黒い半透明の背景 */
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            z-index: 10000; /* 常に最前面に表示 */

            /* 中の要素を中央に配置 */
            justify-content: center;
            align-items: center;
            flex-direction: column; /* 要素を縦に並べる */
        }

        /* 撮影した画像のスタイル */
        #preview img {
            max-width: 90%; /* 画面幅の90%を最大幅に */
            max-height: 70%; /* 画面高さの70%を最大高に */
            border: 2px solid white;
            border-radius: 8px;
        }

        /* 操作案内のテキストスタイル */
        #preview p {
            color: white;
            font-size: 18px;
            font-family: sans-serif;
            margin-top: 20px;
            font-weight: bold;
        }

        /* 閉じるボタンのスタイル */
        #closeBtn {
            margin-top: 15px;
            padding: 12px 25px;
            font-size: 16px;
            background-color: #333;
            color: white;
            border: 1px solid white;
            border-radius: 20px;
            cursor: pointer;
        }

        /* 撮影ボタンのスタイル */
        #captureBtn {
            position: absolute;
            bottom: 30px; /* 位置を下に変更 */
            left: 50%;
            transform: translateX(-50%);
            z-index: 9999;
            padding: 0;
            width: 70px; /* 円形にする */
            height: 70px;
            border-radius: 50%;
            font-size: 30px;
            background-color: white;
            border: 5px solid rgba(0, 0, 0, 0.3);
            box-sizing: border-box;
        }
    </style>
</head>

<body style="margin: 0; overflow: hidden;">
    <!-- 📷 撮影ボタン -->
    <button id="captureBtn">📷</button>

    <!-- 撮影した画像をプレビュー表示するための領域 -->
    <div id="preview">
        <img id="previewImage" src="" alt="キャプチャ画像">
        <p>画像を長押しして保存してください</p>
        <button id="closeBtn">閉じる</button>
    </div>

    <!-- ARシーン -->
    <a-scene
        vr-mode-ui="enabled: false;"
        loading-screen="enabled: false;"
        renderer="logarithmicDepthBuffer: true; antialias: true; colorManagement: true; preserveDrawingBuffer: true;"
        arjs="trackingMethod: best; sourceType: webcam; debugUIEnabled: false;"
        embedded
        gesture-detector
        <!-- 参考コードの方式を使うため、A-Frameのscreenshot機能を有効化 -->
        screenshot
    >
        <a-assets>
             <!-- 複数モデル -->
             <a-asset-item id="model1" src="assets/model1.glb"></a-asset-item>
             <a-asset-item id="model2" src="assets/model2.glb"></a-asset-item>
             <a-asset-item id="model3" src="assets/model3.glb"></a-asset-item>
        </a-assets>

        <!-- マーカー1 → model1 -->
        <a-marker type="pattern" url="assets/marker1.patt">
             <!-- 【修正】座標系を補正するための親エンティティを追加 -->
             <a-entity rotation="-90 0 0">
                <a-entity gltf-model="#model1" scale="0.5 0.5 0.5" gesture-handler></a-entity>
             </a-entity>
        </a-marker>

        <!-- マーカー2 → model2 -->
        <a-marker type="pattern" url="assets/marker2.patt">
             <!-- 【修正】座標系を補正するための親エンティティを追加 -->
             <a-entity rotation="-90 0 0">
                <a-entity gltf-model="#model2" scale="0.5 0.5 0.5" gesture-handler></a-entity>
             </a-entity>
        </a-marker>

        <!-- マーカー3 → model3 -->
        <a-marker type="pattern" url="assets/marker3.patt">
             <!-- 【修正】座標系を補正するための親エンティティを追加 -->
             <a-entity rotation="-90 0 0">
                <a-entity gltf-model="#model3" scale="0.5 0.5 0.5" gesture-handler></a-entity>
             </a-entity>
        </a-marker>

        <a-entity camera></a-entity>
    </a-scene>

    <!-- 撮影スクリプト -->
    <script>
        const sceneEl = document.querySelector("a-scene");
        const captureBtn = document.getElementById("captureBtn");
        const preview = document.getElementById("preview");
        const previewImage = document.getElementById("previewImage");
        const closeBtn = document.getElementById("closeBtn");

        captureBtn.addEventListener("click", () => {
            // ARの映像と3Dモデルを合成して撮影する
            const video = document.querySelector('video'); // AR.jsが生成するvideo要素
            
            // A-Frameのscreenshotコンポーネントを使って3Dモデルが描画されたcanvasを取得
            const aSceneCanvas = sceneEl.components.screenshot.getCanvas("perspective");

            if (!video || !aSceneCanvas) {
                console.error('ARの映像または3Dシーンが見つかりません。');
                return;
            }

            // 最終的な画像を生成するための一時的なcanvasを作成
            const compositeCanvas = document.createElement('canvas');
            const ctx = compositeCanvas.getContext('2d');

            // canvasのサイズをカメラ映像の実際の解像度に合わせる（縦横の圧縮を防ぐため）
            const videoWidth = video.videoWidth;
            const videoHeight = video.videoHeight;
            compositeCanvas.width = videoWidth;
            compositeCanvas.height = videoHeight;

            // 1. 背景として、現在のカメラ映像を描画
            // 2. その上に3Dモデル(A-Frame canvas)を重ねる
const sceneAspectRatio = aSceneCanvas.width / aSceneCanvas.height;
const videoAspectRatio = videoWidth / videoHeight;

let drawWidth, drawHeight, offsetX, offsetY;

if (sceneAspectRatio > videoAspectRatio) {
    // シーンの方が横長 → 横を基準に縮小
    drawWidth = videoWidth;
    drawHeight = videoWidth / sceneAspectRatio;
    offsetX = 0;
    offsetY = (videoHeight - drawHeight) / 2;
} else {
    // シーンの方が縦長 → 縦を基準に縮小
    drawHeight = videoHeight;
    drawWidth = videoHeight * sceneAspectRatio;
    offsetX = (videoWidth - drawWidth) / 2;
    offsetY = 0;
}

// アスペクト比を維持して中央に描画
ctx.drawImage(aSceneCanvas, offsetX, offsetY, drawWidth, drawHeight);

            
            // 2. その上に3Dモデル(A-Frame canvas)を重ねる
            const sceneAspectRatio = aSceneCanvas.width / aSceneCanvas.height;
            const videoAspectRatio = videoWidth / videoHeight;

            let drawWidth, drawHeight, offsetX, offsetY;

            if (sceneAspectRatio > videoAspectRatio) {
                // シーンの方が横長 → 横を基準に縮小
                drawWidth = videoWidth;
                drawHeight = videoWidth / sceneAspectRatio;
                offsetX = 0;
                offsetY = (videoHeight - drawHeight) / 2;
            } else {
                // シーンの方が縦長 → 縦を基準に縮小
                drawHeight = videoHeight;
                drawWidth = videoHeight * sceneAspectRatio;
                offsetX = (videoWidth - drawWidth) / 2;
                offsetY = 0;
            }

            // アスペクト比を維持して中央に描画
            ctx.drawImage(aSceneCanvas, offsetX, offsetY, drawWidth, drawHeight);
            
            // 3. 合成したcanvasから画像データ(DataURL)を生成
            const dataURL = compositeCanvas.toDataURL('image/png');

            // プレビュー用のimgタグに画像データを設定
            previewImage.src = dataURL;
            
            // プレビュー画面を表示
            preview.style.display = "flex";
        });

        // 閉じるボタンが押されたらプレビュー画面を非表示にする
        closeBtn.addEventListener("click", () => {
            preview.style.display = "none";
        });
    </script>
</body>
</html>

